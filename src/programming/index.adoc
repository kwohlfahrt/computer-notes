= Concepts

This document describes some concepts which are common to many programming
languages. You are free to skip it and make a start with the <<Languages>>
below.

== Imperative & Declarative

The most straightforward way to think about a computer program is as a list of
instructions for the computer to run. Broadly, this know known as _imperative
programming_. These instructions are then translated into a form that can be
executed by the hardware inside the computer.

Declarative programming by contrast is about finding a way to express the
desired result, e.g. in a mathematical formula. A tool such as a compiler is
then left to figure out the details of how to achieve this.

== Variables

The ability to assign values to variables is a common feature of programming
languages. Whether the value of a variable can be modified after it has been
assigned varies, in imperative languages they usually can be modified, in
declarative ones this is often not possible.

== Functions

Another common feature is the ability to define functions, or sections of code
that can be re-used. Like mathematical functions they take some values as
inputs, and produce some new values as outputs. They may also have side-effects,
such as showing output on the screen, or creating a file. In declarative
languages, possible side-effects are often restricted.

== Typing

Many programming languages allow (or require) the programmer to provide
additional information about the types of variables. This can be useful in
preventing errors or helping the user reason about the program. For example, if
the variable `result` is declared as a `Boolean` variable (`True` or `False`),
it may not hold any other values. The programmer then cannot assign `"this
text"` to this variable, or to multiply it with a number.

Although this is restrictive, it is a useful feature for catching errors early,
and the type of a functions inputs and outputs can be useful documentation of
what it does.

Types may either be static, which means they are explicitly declared for a
variable and cannot be changed, or dynamic where the type of a variable depends
on what is assigned to it. Modern statically-typed languages often have
type-inference, where the type of a variable is deduced from the value assigned
to it (but it still cannot be changed).

== Compiling & Interpreting

There are two approaches to translating computer programs into a form that can
be run by the hardware. The first is compiling, where a tool (the _compiler_)
reads the entire program and generates a binary file that can be run. The second
is interpreting, where an _interpreter_ reads the program line-by-line, and
executes the appropriate action.

In general, compiled languages are faster, as it leaves more scope for the
compiler to optimize the program. There are many hybrid implementations, for
example the PyPy Python implementation functions as an interpreter, but
compiles frequently used sections of the program while it is running to speed it
up. Haskell is usually a compiled language, but interpreters for it exist
which can be useful for prototyping and teaching.


== Escaping

Escaping is a way of representing text which would otherwise be unrepresentable
in a specific format. This is usually achieved in one of two ways.

=== Escape Sequences

A special escape character (frequently `\`) signals that the following
character has a special meaning. For example, to represent a double quote
(`"`) in a string delimited by double quotes, use the sequence `\"`. In C
for example:

 int main(void) {
   char my_str[] = "This string contains a special character: \".";
   puts(my_str);
   return 0;
 }

This will print:

 This string contains a special character: ".

This means that `\` is itself a special character and must be escaped as
`\\`. Other common escape sequences include `\n` for a new-line and `\t`
for a tab.

=== Doubling

In some cases, a special character can be doubled instead of preceeding it with
an escape character. For example, Python's string formatting syntax uses curly
braces (`{}`) to substitute values:

 >>> "my name is: {}".format("John Doe")
 "my name is: John Doe"

This makes it difficult to include curly braces in a string:

 >>> "curly braces look like this: '{' and '}', and my name is: {}".format("John Doe")
 Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
 KeyError: "' and '"

Instead, they should be doubled:

 >>> "curly braces look like this: '{{' and '}}', and my name is: {}".format("John Doe")
 "curly braces look like this: '{' and '}', and my name is: John Doe

Using `{{` does not activate the formatting machinery, and is replaced with
`{` in the final text (and similarly for `}}`).

== Complexity

The complexity of a program is how a property (e.g. running time, memory usage)
changes with the size of its input. There are several different kinds of
complexity:

O(·):: The upper bound (grows asymptotically no faster than)
Ω(·):: The lower bound (grows asymptotically at least as fast as)
Θ(·):: Both lower and upper bounds (grows asymptotically as fast as)

Of these, O(·) is most commonly used, as it is not always possible to give Θ(⋅),
and often the upper-bound is the most important value.

This only refers to the relation between the property and the input size, two
programs with the same run-time complexity may have 1000-fold differences in the
running-time for the same input.

=== Amortization

Some operations only acheive a certain complexity when averaged over a large
number of repetitions. For example, appending to a continuous vector is O(n) if
the vector has to be resized to fit the new element. However, if the reserved
space of the vector is doubled every time resizing is necessary, appending is
amortized O(1), as the complexity of a resize is O(n), and a resize occurs every
n insertions.
